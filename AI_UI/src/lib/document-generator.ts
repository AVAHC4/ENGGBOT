import { 
  Document, 
  Packer, 
  Paragraph, 
  TextRun, 
  HeadingLevel, 
  AlignmentType,
  ShadingType,
  BorderStyle
} from 'docx';
import { saveAs } from 'file-saver';
import jsPDF from 'jspdf';
import * as pdfMake from 'pdfmake/build/pdfmake';
import * as pdfFonts from 'pdfmake/build/vfs_fonts';

// Configure pdfMake
(pdfMake as any).vfs = pdfFonts.pdfMake.vfs;

export interface DocumentOptions {
  title?: string;
  author?: string;
  subject?: string;
  content: string;
  codeLanguage?: string;
}

/**
 * Generate and download a Word document
 */
export async function generateWordDocument(options: DocumentOptions): Promise<void> {
  const { title = 'Document', author = 'AI Compiler', content } = options;
  
  // Process content by lines
  const lines = content.split('\n');
  let paragraphs: Paragraph[] = [];
  
  // Add title
  paragraphs.push(
    new Paragraph({
      text: title,
      heading: HeadingLevel.HEADING_1,
      alignment: AlignmentType.CENTER
    })
  );

  // Convert content to paragraphs
  let currentParagraph: string[] = [];
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // If empty line, add paragraph and reset
    if (line.trim() === '') {
      if (currentParagraph.length > 0) {
        // Create paragraph with proper text runs for code formatting
        const paragraph = new Paragraph({
          children: [
            new TextRun({
              text: currentParagraph.join('\n'),
              font: options.codeLanguage ? 'Courier New' : undefined,
              size: options.codeLanguage ? 20 : undefined
            })
          ],
          shading: options.codeLanguage ? {
            type: ShadingType.CLEAR,
            color: "auto",
            fill: "F5F5F5"
          } : undefined,
          border: options.codeLanguage ? {
            top: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
            bottom: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
            left: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
            right: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" }
          } : undefined,
          spacing: {
            before: 120,
            after: 120
          }
        });
        paragraphs.push(paragraph);
        currentParagraph = [];
      }
      paragraphs.push(new Paragraph({}));
    } else {
      currentParagraph.push(line);
    }
  }
  
  // Add any remaining paragraph
  if (currentParagraph.length > 0) {
    // Create paragraph with proper text runs for code formatting
    const paragraph = new Paragraph({
      children: [
        new TextRun({
          text: currentParagraph.join('\n'),
          font: options.codeLanguage ? 'Courier New' : undefined,
          size: options.codeLanguage ? 20 : undefined
        })
      ],
      shading: options.codeLanguage ? {
        type: ShadingType.CLEAR,
        color: "auto",
        fill: "F5F5F5"
      } : undefined,
      border: options.codeLanguage ? {
        top: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
        bottom: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
        left: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
        right: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" }
      } : undefined,
      spacing: {
        before: 120,
        after: 120
      }
    });
    paragraphs.push(paragraph);
  }
  
  // Create document with sections and children directly
  const doc = new Document({
    sections: [{
      properties: {},
      children: paragraphs
    }],
    creator: author,
    description: 'Generated by AI Compiler',
    title: title
  });

  // Generate document and save
  const buffer = await Packer.toBlob(doc);
  saveAs(buffer, `${title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.docx`);
}

/**
 * Generate and download a PDF document
 */
export function generatePdfDocument(options: DocumentOptions): void {
  const { title = 'Document', author = 'AI Compiler', content } = options;
  
  // Using pdfMake for more formatting control
  const docDefinition = {
    info: {
      title: title,
      author: author,
      subject: options.subject || 'Generated by AI Compiler',
    },
    content: [
      { text: title, style: 'header' },
      { text: '\n' },
      options.codeLanguage 
        ? { 
            text: content, 
            style: 'code',
            background: '#F5F5F5',
            margin: [5, 5, 5, 5],
            padding: [5, 5, 5, 5]
          }
        : { text: content, style: 'normal' }
    ],
    styles: {
      header: {
        fontSize: 18,
        bold: true,
        marginBottom: 10,
        alignment: 'center'
      },
      normal: {
        fontSize: 12,
      },
      code: {
        font: 'Courier',
        fontSize: 10,
        preserveLeadingSpaces: true,
        lineHeight: 1.2
      }
    },
    defaultStyle: {
      font: 'Helvetica'
    }
  };

  // Generate PDF
  const fileName = `${title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.pdf`;
  pdfMake.createPdf(docDefinition).download(fileName);
}

/**
 * Determine if content is code based on content analysis
 */
export function isCodeContent(content: string, language?: string): boolean {
  if (language && language !== 'text') return true;
  
  const codeKeywords = [
    'function', 'class', 'def ', 'import ', 'for ', 'while ', 'if ', 'else ', 
    'return ', 'var ', 'let ', 'const ', 'public ', 'private ', 'protected ',
    '#include', 'int ', 'void ', 'String', 'boolean', 'print(', 'console.log'
  ];
  
  const codeSymbols = ['{', '}', '=>', '->', ';', '()', '[]'];
  
  // Check if content has multiple lines with code indentation
  const lines = content.split('\n');
  let indentedLines = 0;
  let totalLines = 0;
  
  for (const line of lines) {
    if (line.trim()) {
      totalLines++;
      if (line.startsWith('  ') || line.startsWith('\t')) {
        indentedLines++;
      }
    }
  }
  
  // If more than 15% of lines are indented, likely code
  if (totalLines > 5 && indentedLines / totalLines > 0.15) {
    return true;
  }
  
  // Check for code keywords and symbols
  for (const keyword of codeKeywords) {
    if (content.includes(keyword)) return true;
  }
  
  for (const symbol of codeSymbols) {
    if (content.includes(symbol)) return true;
  }
  
  return false;
} 