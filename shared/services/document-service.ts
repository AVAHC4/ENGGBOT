import { Document, Packer, Paragraph, TextRun, HeadingLevel, Table, TableRow, TableCell, WidthType } from 'docx';
import PDFDocument from 'pdfkit';
import { saveAs } from 'file-saver';
import blobStream from 'blob-stream';

// Document content interface
export interface DocumentContent {
  title: string;
  sections: DocumentSection[];
  author?: string;
  date?: string;
  template?: 'default' | 'resume' | 'report' | 'letter';
}

// Document section interface
export interface DocumentSection {
  title: string;
  content: string | string[];
  type?: 'text' | 'list' | 'table';
  tableData?: any[][];
}

/**
 * Document Service - Handles generation of Word and PDF documents
 */
export class DocumentService {
  /**
   * Creates and downloads a Word document
   */
  public async createAndDownloadWordDocument(
    title: string,
    sections: DocumentSection[],
    author?: string,
    fileName: string = 'document.docx'
  ): Promise<void> {
    try {
      // Create document children array
      const children = [];

      // Add title
      children.push(
        new Paragraph({
          text: title,
          heading: HeadingLevel.HEADING_1,
        })
      );

      // Add author if provided
      if (author) {
        children.push(
          new Paragraph({
            children: [
              new TextRun({
                text: `Author: ${author}`,
                bold: true,
              }),
            ],
          })
        );
      }

      // Add date
      children.push(
        new Paragraph({
          children: [
            new TextRun({
              text: `Date: ${new Date().toLocaleDateString()}`,
              bold: true,
            }),
          ],
          spacing: {
            after: 400,
          },
        })
      );

      // Process each section
      sections.forEach((section) => {
        // Add section title
        children.push(
          new Paragraph({
            text: section.title,
            heading: HeadingLevel.HEADING_2,
          })
        );

        // Process section content based on type
        if (section.type === 'list' && Array.isArray(section.content)) {
          section.content.forEach((item) => {
            children.push(
              new Paragraph({
                children: [
                  new TextRun('• '),
                  new TextRun(item),
                ],
                spacing: {
                  before: 100,
                },
              })
            );
          });
        } else if (section.type === 'table' && section.tableData) {
          const rows = section.tableData.map((rowData) => {
            return new TableRow({
              children: rowData.map((cellData) => {
                return new TableCell({
                  children: [new Paragraph(cellData.toString())],
                  width: {
                    size: 100 / rowData.length,
                    type: WidthType.PERCENTAGE,
                  },
                });
              }),
            });
          });

          children.push(
            new Table({
              rows,
              width: {
                size: 100,
                type: WidthType.PERCENTAGE,
              },
            })
          );
        } else {
          // Default to text
          const content = typeof section.content === 'string' 
            ? section.content 
            : section.content.join('\n');
          
          const paragraphs = content.split('\n').map((paragraph) => {
            return new Paragraph({
              children: [new TextRun(paragraph)],
              spacing: {
                before: 120,
                after: 120,
              },
            });
          });
          
          children.push(...paragraphs);
        }
      });

      // Create document
      const doc = new Document({
        sections: [
          {
            properties: {},
            children: children
          }
        ],
        creator: author || 'AI Document Generator',
        title,
        description: `Document generated by AI: ${title}`
      });

      // Generate and save the document
      const buffer = await Packer.toBuffer(doc);
      const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
      saveAs(blob, fileName);

      return Promise.resolve();
    } catch (error) {
      console.error('Error creating Word document:', error);
      return Promise.reject(error);
    }
  }

  /**
   * Creates and downloads a PDF document
   */
  public async createAndDownloadPdfDocument(
    title: string,
    sections: DocumentSection[],
    author?: string,
    fileName: string = 'document.pdf'
  ): Promise<void> {
    try {
      // Create a document
      const doc = new PDFDocument({ margin: 50 });

      // Pipe its output to a blob
      const stream = doc.pipe(blobStream() as any);

      // Add title
      doc.fontSize(24).font('Helvetica-Bold').text(title, { align: 'center' });
      doc.moveDown();

      // Add author if provided
      if (author) {
        doc.fontSize(12).font('Helvetica').text(`Author: ${author}`);
        doc.moveDown(0.5);
      }

      // Add date
      doc.fontSize(12).font('Helvetica').text(`Date: ${new Date().toLocaleDateString()}`);
      doc.moveDown(2);

      // Process each section
      sections.forEach((section) => {
        // Add section title
        doc.fontSize(16).font('Helvetica-Bold').text(section.title);
        doc.moveDown();

        // Process section content based on type
        if (section.type === 'list' && Array.isArray(section.content)) {
          section.content.forEach((item) => {
            doc.fontSize(12).font('Helvetica').text(`• ${item}`);
            doc.moveDown(0.5);
          });
        } else if (section.type === 'table' && section.tableData) {
          // Simple table implementation
          const tableData = section.tableData;
          const colWidth = 500 / tableData[0].length;
          
          tableData.forEach((row, rowIndex) => {
            let y = doc.y;
            row.forEach((cell, colIndex) => {
              doc.fontSize(12)
                .font(rowIndex === 0 ? 'Helvetica-Bold' : 'Helvetica')
                .text(
                  cell.toString(),
                  50 + colIndex * colWidth,
                  y,
                  { width: colWidth - 10 }
                );
            });
            doc.moveDown();
          });
          
          doc.moveDown();
        } else {
          // Default to text
          const content = typeof section.content === 'string' 
            ? section.content 
            : section.content.join('\n');
          
          doc.fontSize(12).font('Helvetica').text(content);
          doc.moveDown();
        }
        
        doc.moveDown();
      });

      // Finalize the PDF and end the stream
      doc.end();

      // When the stream is done, create a blob and download it
      return new Promise<void>((resolve, reject) => {
        (stream as any).on('finish', () => {
          const blob = (stream as any).toBlob('application/pdf');
          saveAs(blob, fileName);
          resolve();
        });
        
        (stream as any).on('error', (err: any) => {
          reject(err);
        });
      });
    } catch (error) {
      console.error('Error creating PDF document:', error);
      return Promise.reject(error);
    }
  }

  /**
   * Helper function to parse AI output into a structured document
   */
  public parseAIOutputToDocument(aiOutput: string): DocumentContent {
    // Basic parsing logic - can be enhanced for better structure detection
    const lines = aiOutput.split('\n').filter(line => line.trim().length > 0);
    
    let title = 'AI Generated Document';
    const sections: DocumentSection[] = [];
    let currentSection: DocumentSection | null = null;
    
    lines.forEach((line, index) => {
      // Check if this is a title (first non-empty line or a line starting with # or ##)
      if (index === 0 || line.startsWith('# ')) {
        title = line.replace(/^#+ /, '').trim();
      } 
      // Check if this is a section header
      else if (line.startsWith('## ')) {
        // If we have a current section, push it to sections
        if (currentSection) {
          sections.push(currentSection);
        }
        
        // Start a new section
        currentSection = {
          title: line.replace(/^## /, '').trim(),
          content: [],
          type: 'text'
        };
      }
      // Check if this is a list item
      else if (line.match(/^[*\-] /)) {
        // If we don't have a current section or the current section is not a list
        if (!currentSection || currentSection.type !== 'list') {
          // If we have a current section, push it to sections
          if (currentSection) {
            sections.push(currentSection);
          }
          
          // Start a new list section
          currentSection = {
            title: 'List',
            content: [],
            type: 'list'
          };
        }
        
        // Add the list item
        (currentSection.content as string[]).push(line.replace(/^[*\-] /, '').trim());
      }
      // Otherwise, add to the current section or create a new one
      else {
        if (!currentSection) {
          currentSection = {
            title: 'Content',
            content: [],
            type: 'text'
          };
        }
        
        if (currentSection.type === 'text') {
          (currentSection.content as string[]).push(line);
        } else {
          // If we have a list section but this is not a list item, create a new text section
          sections.push(currentSection);
          currentSection = {
            title: 'Content',
            content: [line],
            type: 'text'
          };
        }
      }
    });
    
    // Add the last section if it exists
    if (currentSection) {
      sections.push(currentSection);
    }
    
    // Convert text section content arrays to strings
    sections.forEach(section => {
      if (section.type === 'text' && Array.isArray(section.content)) {
        section.content = (section.content as string[]).join('\n');
      }
    });
    
    return {
      title,
      sections
    };
  }
}

// Document templates
export const documentTemplates = {
  resume: {
    title: 'Professional Resume',
    sections: [
      { title: 'Summary', content: '', type: 'text' },
      { title: 'Experience', content: '', type: 'text' },
      { title: 'Education', content: '', type: 'text' },
      { title: 'Skills', content: [], type: 'list' }
    ]
  },
  report: {
    title: 'Report',
    sections: [
      { title: 'Executive Summary', content: '', type: 'text' },
      { title: 'Introduction', content: '', type: 'text' },
      { title: 'Findings', content: '', type: 'text' },
      { title: 'Conclusion', content: '', type: 'text' },
      { title: 'Recommendations', content: [], type: 'list' }
    ]
  },
  letter: {
    title: 'Formal Letter',
    sections: [
      { title: 'Greeting', content: '', type: 'text' },
      { title: 'Body', content: '', type: 'text' },
      { title: 'Closing', content: '', type: 'text' }
    ]
  }
}; 